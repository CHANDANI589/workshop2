// Super Asset Balance Hook
// Generated by Cradle - https://cradle-web-eight.vercel.app

'use client';

import { useAccount, usePublicClient } from 'wagmi';
import { useQuery } from '@tanstack/react-query';
import type { SuperAssetSymbol, SuperAssetBalance } from '../types/super-assets';
import { SUPER_ASSET_ABI } from '../abi/super-assets';
import { getSuperAssetAddress, SUPER_ASSETS } from '../config/super-assets-config';

/**
 * Hook for getting Super Asset balance
 */
export function useSuperAssetBalance(asset: SuperAssetSymbol) {
  const { address } = useAccount();
  const publicClient = usePublicClient();

  const superAssetAddress = getSuperAssetAddress(asset);

  const { data: balance, isLoading, error, refetch } = useQuery({
    queryKey: ['super-asset-balance', asset, address],
    queryFn: async (): Promise<SuperAssetBalance | null> => {
      if (!address || !publicClient) return null;

      try {
        const [rawBalance, exchangeRate, pendingYield] = await Promise.all([
          publicClient.readContract({
            address: superAssetAddress,
            abi: SUPER_ASSET_ABI,
            functionName: 'balanceOf',
            args: [address],
          }),
          publicClient.readContract({
            address: superAssetAddress,
            abi: SUPER_ASSET_ABI,
            functionName: 'exchangeRate',
          }),
          publicClient.readContract({
            address: superAssetAddress,
            abi: SUPER_ASSET_ABI,
            functionName: 'pendingYield',
            args: [address],
          }),
        ]);

        const underlyingValue = (BigInt(rawBalance) * BigInt(exchangeRate)) / BigInt(1e18);

        return {
          asset,
          balance: BigInt(rawBalance),
          underlyingValue,
          pendingYield: BigInt(pendingYield),
          totalYieldEarned: BigInt(0), // Would fetch from history
        };
      } catch (err) {
        console.error('Failed to fetch balance:', err);
        return null;
      }
    },
    enabled: !!address && !!publicClient,
    refetchInterval: 15_000,
  });

  return {
    balance: balance?.balance ?? BigInt(0),
    underlyingValue: balance?.underlyingValue ?? BigInt(0),
    pendingYield: balance?.pendingYield ?? BigInt(0),
    isLoading,
    error,
    refetch,
  };
}

/**
 * Hook for getting all Super Asset balances
 */
export function useAllSuperAssetBalances() {
  const { address } = useAccount();
  const publicClient = usePublicClient();

  const { data: balances, isLoading, error, refetch } = useQuery({
    queryKey: ['all-super-asset-balances', address],
    queryFn: async (): Promise<SuperAssetBalance[]> => {
      if (!address || !publicClient) return [];

      const results = await Promise.all(
        SUPER_ASSETS.map(async (asset) => {
          try {
            const [rawBalance, exchangeRate, pendingYield] = await Promise.all([
              publicClient.readContract({
                address: asset.address,
                abi: SUPER_ASSET_ABI,
                functionName: 'balanceOf',
                args: [address],
              }),
              publicClient.readContract({
                address: asset.address,
                abi: SUPER_ASSET_ABI,
                functionName: 'exchangeRate',
              }),
              publicClient.readContract({
                address: asset.address,
                abi: SUPER_ASSET_ABI,
                functionName: 'pendingYield',
                args: [address],
              }),
            ]);

            return {
              asset: asset.symbol as SuperAssetSymbol,
              balance: BigInt(rawBalance),
              underlyingValue: (BigInt(rawBalance) * BigInt(exchangeRate)) / BigInt(1e18),
              pendingYield: BigInt(pendingYield),
              totalYieldEarned: BigInt(0),
            };
          } catch {
            return null;
          }
        })
      );

      return results.filter((r): r is SuperAssetBalance => r !== null);
    },
    enabled: !!address && !!publicClient,
    refetchInterval: 30_000,
  });

  return {
    balances: balances ?? [],
    isLoading,
    error,
    refetch,
  };
}